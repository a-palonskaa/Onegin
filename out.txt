

Backward sorting:
    }
    }
    }
    }
    }
    }
    }
    }
    }
//         /...
//ХУЙНЯ - добавить файл для логера и в аргументы командной строки чтобиожно было записфвать имя файла
//    /
    // ХУЙНЯ: add func
//         src/
//         src/
//         src/
//     build/
//         include/
//         include/
//         include/
//     makefile
//         makefile
//         makefile
//         makefile
    LoggerSetFile(logger_output_file);
        perror("FAILED TO OPEN LOGGER OUTPUT FILE");
    SortAndPrintText(&text, &flags, output_file);
// TODO: another layout: rle
        return EXIT_FAILURE;
        return EXIT_FAILURE;
        return EXIT_FAILURE;
        return EXIT_FAILURE;
        return EXIT_FAILURE;
        return EXIT_FAILURE;
    else {
    if (fclose(input_file) == EOF) {
    if (fclose(output_file) == EOF) {
    LoggerSetLevel(DEBUG);
#include <stdlib.h>
#include "text_t_lib.h"
#include <string.h>
#include <stdio.h>
#include "logger.h"
#include "arg_parser.h"
#include "string_functions.h"
#include "print_results.h"
#include "define_constants.h"
#include "sort_and_print.h"
#include "sort.h"
//     onegin/
//     common/
// TODO
const char* LOGGER_OUTPUT = "./output/info";
        Log(ERROR, "FAILED TO CLOSE INPUT FILE\n", STRERROR(errno));
        Log(ERROR, "FAILED TO OPEN INPUT FILE\n", STRERROR(errno));
        Log(ERROR, "FAILED TO CLOSE OUTPUT FILE\n", STRERROR(errno));
        Log(ERROR, "FAILED TO OPEN OUTPUT FILE\n", STRERROR(errno));
    FILE* input_file  = fopen(flags.input_file_name, "r");
    if (ArgParser(argc, argv, &flags) == INPUT_ERROR) {
    if (input_file == nullptr) {
    if (output_file == nullptr) {
    if (logger_output_file == nullptr) {
    InitiallizeFlags(&flags);
    flags_t flags = {};
// ХУЙНЯ: add const in all definitions but no decls
    if (StringCtor(&text, input_file) != NO_ERRORS) {
    return EXIT_SUCCESS;
        text.sort_state = DEFAULT;
    if (flags.sort_mode_cnt) {
//     header_sort/
        logger_output_file = stdout;
    StringDtor(&text);
    text_t text = {};
int main(int argc, const char* argv[]) {
    FILE* output_file = fopen(flags.output_file_name, "w");
    FILE* logger_output_file = fopen(LOGGER_OUTPUT, "w");
        text.sort_state = COMPLEX;
}


Backward sorting:
    }
    }
    }
    }
    }
    }
    }
    }
    }
//         /...
//ХУЙНЯ - добавить файл для логера и в аргументы командной строки чтобиожно было записфвать имя файла
//    /
    // ХУЙНЯ: add func
//         src/
//         src/
//         src/
//     build/
//         include/
//         include/
//         include/
//     makefile
//         makefile
//         makefile
//         makefile
    LoggerSetFile(logger_output_file);
        perror("FAILED TO OPEN LOGGER OUTPUT FILE");
    SortAndPrintText(&text, &flags, output_file);
// TODO: another layout: rle
        return EXIT_FAILURE;
        return EXIT_FAILURE;
        return EXIT_FAILURE;
        return EXIT_FAILURE;
        return EXIT_FAILURE;
        return EXIT_FAILURE;
    else {
    if (fclose(input_file) == EOF) {
    if (fclose(output_file) == EOF) {
    LoggerSetLevel(DEBUG);
#include <stdlib.h>
#include "text_t_lib.h"
#include <string.h>
#include <stdio.h>
#include "logger.h"
#include "arg_parser.h"
#include "string_functions.h"
#include "print_results.h"
#include "define_constants.h"
#include "sort_and_print.h"
#include "sort.h"
//     onegin/
//     common/
// TODO
const char* LOGGER_OUTPUT = "./output/info";
        Log(ERROR, "FAILED TO CLOSE INPUT FILE\n", STRERROR(errno));
        Log(ERROR, "FAILED TO OPEN INPUT FILE\n", STRERROR(errno));
        Log(ERROR, "FAILED TO CLOSE OUTPUT FILE\n", STRERROR(errno));
        Log(ERROR, "FAILED TO OPEN OUTPUT FILE\n", STRERROR(errno));
    FILE* input_file  = fopen(flags.input_file_name, "r");
    if (ArgParser(argc, argv, &flags) == INPUT_ERROR) {
    if (input_file == nullptr) {
    if (output_file == nullptr) {
    if (logger_output_file == nullptr) {
    InitiallizeFlags(&flags);
    flags_t flags = {};
// ХУЙНЯ: add const in all definitions but no decls
    if (StringCtor(&text, input_file) != NO_ERRORS) {
    return EXIT_SUCCESS;
        text.sort_state = DEFAULT;
    if (flags.sort_mode_cnt) {
//     header_sort/
        logger_output_file = stdout;
    StringDtor(&text);
    text_t text = {};
int main(int argc, const char* argv[]) {
    FILE* output_file = fopen(flags.output_file_name, "w");
    FILE* logger_output_file = fopen(LOGGER_OUTPUT, "w");
        text.sort_state = COMPLEX;
}


Forward sorting:
    }
    }
    }
    }
    }
    }
    }
    }
    }
//         /...
//ХУЙНЯ - добавить файл для логера и в аргументы командной строки чтобиожно было записфвать имя файла
//    /
    // ХУЙНЯ: add func
//         src/
//         src/
//         src/
//     build/
//         include/
//         include/
//         include/
//     makefile
//         makefile
//         makefile
//         makefile
    LoggerSetFile(logger_output_file);
        perror("FAILED TO OPEN LOGGER OUTPUT FILE");
    SortAndPrintText(&text, &flags, output_file);
// TODO: another layout: rle
        return EXIT_FAILURE;
        return EXIT_FAILURE;
        return EXIT_FAILURE;
        return EXIT_FAILURE;
        return EXIT_FAILURE;
        return EXIT_FAILURE;
    else {
    if (fclose(input_file) == EOF) {
    if (fclose(output_file) == EOF) {
    LoggerSetLevel(DEBUG);
#include <stdlib.h>
#include "text_t_lib.h"
#include <string.h>
#include <stdio.h>
#include "logger.h"
#include "arg_parser.h"
#include "string_functions.h"
#include "print_results.h"
#include "define_constants.h"
#include "sort_and_print.h"
#include "sort.h"
//     onegin/
//     common/
// TODO
const char* LOGGER_OUTPUT = "./output/info";
        Log(ERROR, "FAILED TO CLOSE INPUT FILE\n", STRERROR(errno));
        Log(ERROR, "FAILED TO OPEN INPUT FILE\n", STRERROR(errno));
        Log(ERROR, "FAILED TO CLOSE OUTPUT FILE\n", STRERROR(errno));
        Log(ERROR, "FAILED TO OPEN OUTPUT FILE\n", STRERROR(errno));
    FILE* input_file  = fopen(flags.input_file_name, "r");
    if (ArgParser(argc, argv, &flags) == INPUT_ERROR) {
    if (input_file == nullptr) {
    if (output_file == nullptr) {
    if (logger_output_file == nullptr) {
    InitiallizeFlags(&flags);
    flags_t flags = {};
// ХУЙНЯ: add const in all definitions but no decls
    if (StringCtor(&text, input_file) != NO_ERRORS) {
    return EXIT_SUCCESS;
        text.sort_state = DEFAULT;
    if (flags.sort_mode_cnt) {
//     header_sort/
        logger_output_file = stdout;
    StringDtor(&text);
    text_t text = {};
int main(int argc, const char* argv[]) {
    FILE* output_file = fopen(flags.output_file_name, "w");
    FILE* logger_output_file = fopen(LOGGER_OUTPUT, "w");
        text.sort_state = COMPLEX;
}
